# Repository

A repository maps to an underlying data store, controlled by the adapter. For example, Ecto ships with a Postgres adapter that stores data into a PostgreSQL database.

When used, the repository expects the :otp_app as option. The :otp_app should point to an OTP application that has the repository configuration. For example, the repository:

```elixir
defmodule Repo do
  use Ecto.Repo, otp_app: :my_app
end
```

Could be configured with:

```elixir
config :my_app, Repo,
  adapter: Ecto.Adapters.Postgres,
  database: "ecto_simple",
  username: "postgres",
  password: "postgres",
  hostname: "localhost"
```

In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the init/2 repository callback:

```elixir
def init(_type, config) do
  {:ok, Keyword.put(config, :url, System.get_env("DATABASE_URL"))}
end
```

Almost all of the repository operations below accept the following options:

1.:timeout - The time in milliseconds to wait for the query call to finish, :infinity will wait indefinitely (default: 15000);
2.:pool_timeout - The time in milliseconds to wait for calls to the pool to finish, :infinity will wait indefinitely (default: 5000);
3.:log - When false, does not log the query


aggregate(queryable, aggregate, field, opts)
Calculate the given aggregate over the given field.

If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result.

Any preload or select in the query will be ignored in favor of the column being aggregated.

The aggregation will fail if any group_by field is set.

```elixir
# Returns the number of visits per blog post
Repo.aggregate(Post, :count, :visits)

# Returns the average number of visits for the top 10
query = from Post, limit: 10
Repo.aggregate(query, :avg, :visits)
```

all(queryable, opts)
Fetches all entries from the data store matching the given query.

May raise Ecto.QueryError if query validation fails.

```elixir
# Fetch all post titles
query = from p in Post,
     select: p.title
MyRepo.all(query)
```


config()
Returns the adapter configuration stored in the :otp_app environment.


delete(struct_or_changeset, opts)
Deletes a struct using its primary key.

If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised.

It returns {:ok, struct} if the struct has been successfully deleted or {:error, changeset} if there was a validation or a known constraint error.

```elixir
post = MyRepo.get!(Post, 42)
case MyRepo.delete post do
  {:ok, struct}       -> # Deleted with success
  {:error, changeset} -> # Something went wrong
end
```

delete!(struct_or_changeset, opts)
Same as delete/2 but returns the struct or raises if the changeset is invalid.


delete_all(queryable, opts)
Deletes all entries matching the given query.

It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in DELETE statements or no return result was selected, the second element will be nil.

```elixir
MyRepo.delete_all(Post)

from(p in Post, where: p.id < 10) |> MyRepo.delete_all
```


get(queryable, id, opts)
Fetches a single struct from the data store where the primary key matches the given id.

Returns nil if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error.

```elixir
MyRepo.get(Post, 42)
```

get_by(queryable, clauses, opts)
Fetches a single result from the query.

Returns nil if no result was found.

```elixir
MyRepo.get_by(Post, title: "My post")
```

in_transaction?()

Returns true if the current process is inside a transaction.

```elixir
MyRepo.in_transaction?
#=> false

MyRepo.transaction(fn ->
  MyRepo.in_transaction? #=> true
end)
```

insert(struct_or_changeset, opts)
Inserts a struct defined via Ecto.Schema or a changeset.

In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.

In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database.

It returns {:ok, struct} if the struct has been successfully inserted or {:error, changeset} if there was a validation or a known constraint error.

```elixir
case MyRepo.insert %Post{title: "Ecto is great"} do
  {:ok, struct}       -> # Inserted with success
  {:error, changeset} -> # Something went wrong
end

{:ok, ignored} = MyRepo.insert(%Post{title: "this is unique"}, on_conflict: :nothing)
```

One possible mechanism to detect if an insert or nothing happened in case of on_conflict: :nothing is by checking the id field. id will be nil if the field is autogenerated by the database and no insert happened.


insert_all(schema_or_source, entries, opts)
Inserts all entries into the repository.

It expects a schema (MyApp.User) or a source ("users") or both ({"users", MyApp.User}) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps.

It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be nil.

```elixir
MyRepo.insert_all(Post, [[title: "My first post"], [title: "My second post"]])
MyRepo.insert_all(Post, [%{title: "My first post"}, %{title: "My second post"}])
```

insert_or_update(changeset, opts)
Inserts or updates a changeset depending on whether the struct is persisted or not.
Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won’t work:
```elixir
struct = %Post{id: "existing_id", ...}
MyRepo.insert_or_update changeset
# => {:error, changeset} # id already exists
```
```elixir
result =
  case MyRepo.get(Post, id) do
    nil  -> %Post{id: id} # Post not found, we build one
    post -> post          # Post exists, let's use it
  end
  |> Post.changeset(changes)
  |> MyRepo.insert_or_update

case result do
  {:ok, struct}       -> # Inserted or updated with success
  {:error, changeset} -> # Something went wrong
end
```

load(arg0, arg1) View Source

Loads data into a struct or a map.
Fields that are not present in the schema (or types map) are ignored. If any of the values has invalid type, an error is raised.


```elixir
 MyRepo.load(User, %{name: "Alice", age: 25})
 MyRepo.load(User, {[:name, :age], ["Alice", 25]})
 ```

one(queryable, opts)
Fetches a single result from the query.

Returns nil if no result was found. Raises if more than one entry.

preload(structs_or_struct_or_nil, preloads, opts)
Preloads all associations on the given struct or structs.

This is similar to Ecto.Query.preload/3 except it allows you to preload structs after they have been fetched from the database.

In case the association was already loaded, preload won’t attempt to reload it.

```elixir
# Use a single atom to preload an association
posts = Repo.preload posts, :comments

# Use a list of atoms to preload multiple associations
posts = Repo.preload posts, [:comments, :authors]

# Use a keyword list to preload nested associations as well
posts = Repo.preload posts, [comments: [:replies, :likes], authors: []]

# Use a keyword list to customize how associations are queried
posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)]

# Use a two-element tuple for a custom query and nested association definition
query = from c in Comment, order_by: c.published_at
posts = Repo.preload posts, [comments: {query, [:replies, :likes]}]
```

stream(queryable, opts)
Returns a lazy enumerable that emits all entries from the data store matching the given query. SQL adapters, such as Postgres and MySQL, can only enumerate a stream inside a transaction.

```elixir
# Fetch all post titles
query = from p in Post,
     select: p.title
stream = MyRepo.stream(query)
MyRepo.transaction(fn() ->
  Enum.to_list(stream)
end)
```

transaction(fun_or_multi, opts)
Runs the given function or Ecto.Multi inside a transaction.
```elixir
import Ecto.Changeset, only: [change: 2]

MyRepo.transaction(fn ->
  MyRepo.update!(change(alice, balance: alice.balance - 10))
  MyRepo.update!(change(bob, balance: bob.balance + 10))
end)

# Roll back a transaction explicitly
MyRepo.transaction(fn ->
  p = MyRepo.insert!(%Post{})
  if not Editor.post_allowed?(p) do
    MyRepo.rollback(:posting_not_allowed)
  end
end)

# With Ecto.Multi
Ecto.Multi.new
|> Ecto.Multi.insert(:post, %Post{})
|> MyRepo.transaction
```

update(changeset, opts)
Updates a changeset using its primary key.

A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the changes part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored.

If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised.

```elixir
post = MyRepo.get!(Post, 42)
post = Ecto.Changeset.change post, title: "New title"
case MyRepo.update post do
  {:ok, struct}       -> # Updated with success
  {:error, changeset} -> # Something went wrong
end
```

update_all(queryable, updates, opts)
Updates all entries matching the given query with the given values.

```elixir
MyRepo.update_all(Post, set: [title: "New title"])

MyRepo.update_all(Post, inc: [visits: 1])

from(p in Post, where: p.id < 10)
|> MyRepo.update_all(set: [title: "New title"])

from(p in Post, where: p.id < 10, update: [set: [title: "New title"]])
|> MyRepo.update_all([])

from(p in Post, where: p.id < 10, update: [set: [title: ^new_title]])
|> MyRepo.update_all([])

from(p in Post, where: p.id < 10, update: [set: [title: fragment("upper(?)", ^new_title)]])
|> MyRepo.update_all([])
```

# Exercises

1.Get count of visits for each post
2.Get count of comments for each post
3.Get average comments on posts
4.Get all post's titles
5.Delete one post
6.Delete posts with comments > 2
7.Get one posts
8.Try to get non existing posts
9.Get by - all posts with title, created_at, ...
10.Insert posts (generated)
11.Try to insert post with the same title (constraint)
12.Try to insert many post at the same time
13.Try to insert many posts at the same time that breaks constraints
14.Insert or update post (you have to fetch it from db)
15.Get one post
16.Load data into struct (posts to some struct) - check what happens when fields do not match.
17.Use preload to fetch associations check generated sqls.
18.Use stream to implement paging.
19.Run all updated and deleted in transation with rollback at the end.
