<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title></title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="lib/css/zenburn.css">
        <link rel="stylesheet" href="css/theme/serif.css" id="theme">
        <link rel="stylesheet" href="css/xcode.css">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h2>RabbitMQ</h2>
                </section>
                <section>
                    <h2>Message</h2>
                </section>
                <section>
                    <h2>Exchange</h2>
                </section>
                <section>
                    <section>
                        <h2>Queue</h2>
                        <p>
                        Queues in RabbitMQ are ordered collections of messages. Messages are enqueued and dequeued (consumed) in the FIFO manner.
                        </p>
                        <ul>
                            <li>Identified by name ("amq." is reserved)</li>
                            <li>If you pass empty name then server will generate it.</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Properties</h3>
                        <ul>
                            <li>Durable</li>
                            <li>
                                Exclusive - can be used only by one connection is deleted when connection closes 
                            </li>
                            <li>Auto-delete</li>
                            <li>Additiona argument</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Arguments</h3>
                        <ul>
                            <li>Queue type (quorum or classic)</li>
                            <li>Message and queue TTL</li>
                            <li>Queue length limit</li>
                            <li>Mirroring options</li>
                            <li>Consumer priorities</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Durability</h3>

                        <ul>
                            <li>Durable queues are persisted to disk and thus survive broker restarts</li>
                            <li>Queues that are not durable are called transient</li>
                            <li>Durability of a queue does not make messages that are routed to that queue durable</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <h2>Scaling</h2>
                </section>
                <section>
                    <section>
                        <h2>Send message</h2>
                        <pre><code data-trim data-noescape>
{:ok, connection} = AMQP.Connection.open
{:ok, channel} = AMQP.Channel.open(connection)
AMQP.Queue.declare(channel, "hello")
AMQP.Basic.publish(channel, "", "hello", "Hello World!")
IO.puts " [x] Sent 'Hello World!'"
AMQP.Connection.close(connection)
                        </code></pre>
                    </section>
                    <section>
                        <h2>Receive message</h2>
                        <pre><code data-trim data-noescape>
{:ok, connection} = AMQP.Connection.open
{:ok, channel} = AMQP.Channel.open(connection)
AMQP.Queue.declare(channel, "hello")
AMQP.Basic.consume(channel, "hello", nil, no_ack: true)
IO.puts " [*] Waiting for messages. To exit press CTRL+C, CTRL+C"

Receive.wait_for_messages() 
                        </code></pre>
                    </section>
                    <section>
                        <pre><code data-trim data-noescape>
defmodule Receive do
  def wait_for_messages do
    receive do
      {:basic_deliver, payload, _meta} ->
        IO.puts " [x] Received #{payload}"
        wait_for_messages()
    end
  end
end
                        </code></pre>
                    </section>
                </section>
            </div>

            <script src="lib/js/head.min.js"></script>
            <script src="js/reveal.js"></script>

            <script>
                Reveal.initialize({
                    transition: 'linear',
                    progress: true
                });
            </script>
            <script src="js/highlight.pack.js"></script>
            <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>
